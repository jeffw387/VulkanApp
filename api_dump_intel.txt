Thread 0, Frame 0:
vkCreateInstance(pCreateInfo, pAllocator, pInstance) returns VkResult VK_SUCCESS (0):
    pCreateInfo:                    const VkInstanceCreateInfo* = 0000006FC2F88FE0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO (1)
        pNext:                          const void* = 0000006FC2F88FC0
        flags:                          VkInstanceCreateFlags = 0
        pApplicationInfo:               const VkApplicationInfo* = 0000006FC2F89F68:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_APPLICATION_INFO (0)
            pNext:                          const void* = NULL
            pApplicationName:               const char* = "AppName"
            applicationVersion:             uint32_t = 4194304
            pEngineName:                    const char* = "VulkanApp"
            engineVersion:                  uint32_t = 4194304
            apiVersion:                     uint32_t = 4194304
        enabledLayerCount:              uint32_t = 0
        ppEnabledLayerNames:            const char* const* = NULL
        enabledExtensionCount:          uint32_t = 3
        ppEnabledExtensionNames:        const char* const* = 0000018D688AF930
            ppEnabledExtensionNames[0]:     const char* const = "VK_EXT_debug_report"
            ppEnabledExtensionNames[1]:     const char* const = "VK_KHR_surface"
            ppEnabledExtensionNames[2]:     const char* const = "VK_KHR_win32_surface"
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pInstance:                      VkInstance* = 0000018D688B2A20

Thread 0, Frame 0:
vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0000018D688B2A20
    pCreateInfo:                    const VkDebugReportCallbackCreateInfoEXT* = 0000006FC2F89248:
        sType:                          VkStructureType = UNKNOWN (1000011000)
        pNext:                          const void* = NULL
        flags:                          VkDebugReportFlagsEXT = 31 (VK_DEBUG_REPORT_INFORMATION_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT | VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT | VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_DEBUG_BIT_EXT)
        pfnCallback:                    PFN_vkDebugReportCallbackEXT = 00007FF7FB772FB0
        pUserData:                      void* = NULL
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pCallback:                      VkDebugReportCallbackEXT* = 0000018D688B7100

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0000018D688B2A20
    pPhysicalDeviceCount:           uint32_t* = 1
    pPhysicalDevices:               VkPhysicalDevice* = NULL

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0000018D688B2A20
    pPhysicalDeviceCount:           uint32_t* = 1
    pPhysicalDevices:               VkPhysicalDevice* = 0000006FC2F89080
        pPhysicalDevices[0]:            VkPhysicalDevice = 0000018D6B17B2A0

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0000018D688B2A20
    pPhysicalDeviceCount:           uint32_t* = 1
    pPhysicalDevices:               VkPhysicalDevice* = NULL

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0000018D688B2A20
    pPhysicalDeviceCount:           uint32_t* = 1
    pPhysicalDevices:               VkPhysicalDevice* = 0000006FC2F89080
        pPhysicalDevices[0]:            VkPhysicalDevice = 0000018D6B17B2A0

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = 0000018D6B17D320
        pQueueFamilyProperties[0]:      VkQueueFamilyProperties = 0000018D6B17D320:
            queueFlags:                     VkQueueFlags = 15 (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT)
            queueCount:                     uint32_t = 1
            timestampValidBits:             uint32_t = 36
            minImageTransferGranularity:    VkExtent3D = 0000018D6B17D32C:
                width:                          uint32_t = 1
                height:                         uint32_t = 1
                depth:                          uint32_t = 1

Thread 0, Frame 0:
vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0000018D688B2A20
    pCreateInfo:                    const VkWin32SurfaceCreateInfoKHR* = 0000006FC2F891D0:
        sType:                          VkStructureType = UNKNOWN (1000009000)
        pNext:                          const void* = NULL
        flags:                          VkWin32SurfaceCreateFlagsKHR = 0
        hinstance:                      HINSTANCE = 00007FF7FB570000
        hwnd:                           HWND = 00000000000C095E
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSurface:                       VkSurfaceKHR* = 0000018D6B16BD40

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC2F88E18:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC2F88E20:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC2F88E28:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC2F88E30:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceFormatCount:            uint32_t* = 4
    pSurfaceFormats:                VkSurfaceFormatKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceFormatCount:            uint32_t* = 4
    pSurfaceFormats:                VkSurfaceFormatKHR* = 0000018D6B17D5C0
        pSurfaceFormats[0]:             VkSurfaceFormatKHR = 0000018D6B17D5C0:
            format:                         VkFormat = VK_FORMAT_R8G8B8A8_UNORM (37)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[1]:             VkSurfaceFormatKHR = 0000018D6B17D5C8:
            format:                         VkFormat = VK_FORMAT_R8G8B8A8_SRGB (43)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[2]:             VkSurfaceFormatKHR = 0000018D6B17D5D0:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_UNORM (44)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[3]:             VkSurfaceFormatKHR = 0000018D6B17D5D8:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pPresentModeCount:              uint32_t* = 2
    pPresentModes:                  VkPresentModeKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pPresentModeCount:              uint32_t* = 2
    pPresentModes:                  VkPresentModeKHR* = 0000018D6B16C130
        pPresentModes[0]:               VkPresentModeKHR = VK_PRESENT_MODE_IMMEDIATE_KHR (0)
        pPresentModes[1]:               VkPresentModeKHR = VK_PRESENT_MODE_FIFO_KHR (2)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    queueFamilyIndex:               uint32_t = 0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSupported:                     VkBool32* = 1

Thread 0, Frame 0:
vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    pCreateInfo:                    const VkDeviceCreateInfo* = 0000006FC2F88FC0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO (3)
        pNext:                          const void* = 0000006FC2F88F98
        flags:                          VkDeviceCreateFlags = 0
        queueCreateInfoCount:           uint32_t = 1
        pQueueCreateInfos:              const VkDeviceQueueCreateInfo* = 0000018D6B184730
            pQueueCreateInfos[0]:           const VkDeviceQueueCreateInfo = 0000018D6B184730:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO (2)
                pNext:                          const void* = NULL
                flags:                          VkDeviceQueueCreateFlags = 0
                queueFamilyIndex:               uint32_t = 0
                queueCount:                     uint32_t = 1
                pQueuePriorities:               const float* = 00007FF7FB7E0228
                    pQueuePriorities[0]:            const float = 0
        enabledLayerCount:              uint32_t = 0
        ppEnabledLayerNames:            const char* const* = NULL
        enabledExtensionCount:          uint32_t = 1
        ppEnabledExtensionNames:        const char* const* = 0000018D6B16BD20
            ppEnabledExtensionNames[0]:     const char* const = "VK_KHR_swapchain"
        pEnabledFeatures:               const VkPhysicalDeviceFeatures* = NULL
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pDevice:                        VkDevice* = 0000018D6B18B040

Thread 0, Frame 0:
vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue) returns void:
    device:                         VkDevice = 0000018D6B18B040
    queueFamilyIndex:               uint32_t = 0
    queueIndex:                     uint32_t = 0
    pQueue:                         VkQueue* = 0000018D6B2D8A58

Thread 0, Frame 0:
vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    pMemoryProperties:              VkPhysicalDeviceMemoryProperties* = 0000006FC2F89070:
        memoryTypeCount:                uint32_t = 2
        memoryTypes:                    VkMemoryType[VK_MAX_MEMORY_TYPES] = 0000006FC2F89074
            memoryTypes[0]:                 VkMemoryType = 0000006FC2F89074:
                propertyFlags:                  VkMemoryPropertyFlags = 7 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[1]:                 VkMemoryType = 0000006FC2F8907C:
                propertyFlags:                  VkMemoryPropertyFlags = 15 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[2]:                 VkMemoryType = 0000006FC2F89084:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[3]:                 VkMemoryType = 0000006FC2F8908C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[4]:                 VkMemoryType = 0000006FC2F89094:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[5]:                 VkMemoryType = 0000006FC2F8909C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[6]:                 VkMemoryType = 0000006FC2F890A4:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[7]:                 VkMemoryType = 0000006FC2F890AC:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[8]:                 VkMemoryType = 0000006FC2F890B4:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[9]:                 VkMemoryType = 0000006FC2F890BC:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[10]:                VkMemoryType = 0000006FC2F890C4:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[11]:                VkMemoryType = 0000006FC2F890CC:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[12]:                VkMemoryType = 0000006FC2F890D4:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[13]:                VkMemoryType = 0000006FC2F890DC:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[14]:                VkMemoryType = 0000006FC2F890E4:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[15]:                VkMemoryType = 0000006FC2F890EC:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[16]:                VkMemoryType = 0000006FC2F890F4:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[17]:                VkMemoryType = 0000006FC2F890FC:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[18]:                VkMemoryType = 0000006FC2F89104:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[19]:                VkMemoryType = 0000006FC2F8910C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[20]:                VkMemoryType = 0000006FC2F89114:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[21]:                VkMemoryType = 0000006FC2F8911C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[22]:                VkMemoryType = 0000006FC2F89124:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[23]:                VkMemoryType = 0000006FC2F8912C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[24]:                VkMemoryType = 0000006FC2F89134:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[25]:                VkMemoryType = 0000006FC2F8913C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[26]:                VkMemoryType = 0000006FC2F89144:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[27]:                VkMemoryType = 0000006FC2F8914C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[28]:                VkMemoryType = 0000006FC2F89154:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[29]:                VkMemoryType = 0000006FC2F8915C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[30]:                VkMemoryType = 0000006FC2F89164:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
            memoryTypes[31]:                VkMemoryType = 0000006FC2F8916C:
                propertyFlags:                  VkMemoryPropertyFlags = 0
                heapIndex:                      uint32_t = 0
        memoryHeapCount:                uint32_t = 1
        memoryHeaps:                    VkMemoryHeap[VK_MAX_MEMORY_HEAPS] = 0000006FC2F89178
            memoryHeaps[0]:                 VkMemoryHeap = 0000006FC2F89178:
                size:                           VkDeviceSize = 7673623142
                flags:                          VkMemoryHeapFlags = 1 (VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
            memoryHeaps[1]:                 VkMemoryHeap = 0000006FC2F89188:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[2]:                 VkMemoryHeap = 0000006FC2F89198:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[3]:                 VkMemoryHeap = 0000006FC2F891A8:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[4]:                 VkMemoryHeap = 0000006FC2F891B8:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[5]:                 VkMemoryHeap = 0000006FC2F891C8:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[6]:                 VkMemoryHeap = 0000006FC2F891D8:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[7]:                 VkMemoryHeap = 0000006FC2F891E8:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[8]:                 VkMemoryHeap = 0000006FC2F891F8:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[9]:                 VkMemoryHeap = 0000006FC2F89208:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[10]:                VkMemoryHeap = 0000006FC2F89218:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[11]:                VkMemoryHeap = 0000006FC2F89228:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[12]:                VkMemoryHeap = 0000006FC2F89238:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[13]:                VkMemoryHeap = 0000006FC2F89248:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[14]:                VkMemoryHeap = 0000006FC2F89258:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0
            memoryHeaps[15]:                VkMemoryHeap = 0000006FC2F89268:
                size:                           VkDeviceSize = 0
                flags:                          VkMemoryHeapFlags = 0

Thread 0, Frame 0:
vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkRenderPassCreateInfo* = 0000006FC2F89208:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO (38)
        pNext:                          const void* = NULL
        flags:                          VkRenderPassCreateFlags = 0
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkAttachmentDescription* = 0000006FC2F8915C
            pAttachments[0]:                const VkAttachmentDescription = 0000006FC2F8915C:
                flags:                          VkAttachmentDescriptionFlags = 0
                format:                         VkFormat = VK_FORMAT_R8G8B8A8_UNORM (37)
                samples:                        VkSampleCountFlagBits = 1 (VK_SAMPLE_COUNT_1_BIT)
                loadOp:                         VkAttachmentLoadOp = VK_ATTACHMENT_LOAD_OP_CLEAR (1)
                storeOp:                        VkAttachmentStoreOp = VK_ATTACHMENT_STORE_OP_STORE (0)
                stencilLoadOp:                  VkAttachmentLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE (2)
                stencilStoreOp:                 VkAttachmentStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE (1)
                initialLayout:                  VkImageLayout = VK_IMAGE_LAYOUT_UNDEFINED (0)
                finalLayout:                    VkImageLayout = UNKNOWN (1000001002)
        subpassCount:                   uint32_t = 1
        pSubpasses:                     const VkSubpassDescription* = 0000006FC2F89188
            pSubpasses[0]:                  const VkSubpassDescription = 0000006FC2F89188:
                flags:                          VkSubpassDescriptionFlags = 0
                pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
                inputAttachmentCount:           uint32_t = 0
                pInputAttachments:              const VkAttachmentReference* = NULL
                colorAttachmentCount:           uint32_t = 1
                pColorAttachments:              const VkAttachmentReference* = 0000006FC2F89180
                    pColorAttachments[0]:           const VkAttachmentReference = 0000006FC2F89180:
                        attachment:                     uint32_t = 0
                        layout:                         VkImageLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL (2)
                pResolveAttachments:            const VkAttachmentReference* = NULL
                pDepthStencilAttachment:        const VkAttachmentReference* = NULL
                preserveAttachmentCount:        uint32_t = 0
                pPreserveAttachments:           const uint32_t* = NULL
        dependencyCount:                uint32_t = 2
        pDependencies:                  const VkSubpassDependency* = 0000006FC2F891D0
            pDependencies[0]:               const VkSubpassDependency = 0000006FC2F891D0:
                srcSubpass:                     uint32_t = 0
                dstSubpass:                     uint32_t = 0
                srcStageMask:                   VkPipelineStageFlags = 8192 (VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT)
                dstStageMask:                   VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
                srcAccessMask:                  VkAccessFlags = 32768 (VK_ACCESS_MEMORY_READ_BIT)
                dstAccessMask:                  VkAccessFlags = 384 (VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT)
                dependencyFlags:                VkDependencyFlags = 1 (VK_DEPENDENCY_BY_REGION_BIT)
            pDependencies[1]:               const VkSubpassDependency = 0000006FC2F891EC:
                srcSubpass:                     uint32_t = 0
                dstSubpass:                     uint32_t = 0
                srcStageMask:                   VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
                dstStageMask:                   VkPipelineStageFlags = 8192 (VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT)
                srcAccessMask:                  VkAccessFlags = 384 (VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT)
                dstAccessMask:                  VkAccessFlags = 32768 (VK_ACCESS_MEMORY_READ_BIT)
                dependencyFlags:                VkDependencyFlags = 1 (VK_DEPENDENCY_BY_REGION_BIT)
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pRenderPass:                    VkRenderPass* = 0000018D6B2D51D8

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC2F88D68:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC2F88D70:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC2F88D78:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC2F88D80:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkSwapchainCreateInfoKHR* = 0000006FC2F89150:
        sType:                          VkStructureType = UNKNOWN (1000001000)
        pNext:                          const void* = NULL
        flags:                          VkSwapchainCreateFlagsKHR = 0
        surface:                        VkSurfaceKHR = 0000018D6B16BD40
        minImageCount:                  uint32_t = 3
        imageFormat:                    VkFormat = VK_FORMAT_R8G8B8A8_UNORM (37)
        imageColorSpace:                VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        imageExtent:                    VkExtent2D = 0000006FC2F8917C:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        imageArrayLayers:               uint32_t = 1
        imageUsage:                     VkImageUsageFlags = 16 (VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
        imageSharingMode:               VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 0
        pQueueFamilyIndices:            const uint32_t* = UNUSED
        preTransform:                   VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        compositeAlpha:                 VkCompositeAlphaFlagBitsKHR = 1 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR)
        presentMode:                    VkPresentModeKHR = VK_PRESENT_MODE_FIFO_KHR (2)
        clipped:                        VkBool32 = 0
        oldSwapchain:                   VkSwapchainKHR = 0000000000000000
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSwapchain:                     VkSwapchainKHR* = 0000018D6B185FE8

Thread 0, Frame 0:
vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    pSwapchainImageCount:           uint32_t* = 3
    pSwapchainImages:               VkImage* = NULL

Thread 0, Frame 0:
vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    pSwapchainImageCount:           uint32_t* = 3
    pSwapchainImages:               VkImage* = 0000018D6B3781F0
        pSwapchainImages[0]:            VkImage = 0000018D7177B288
        pSwapchainImages[1]:            VkImage = 0000018D7177E358
        pSwapchainImages[2]:            VkImage = 0000018D717A1438

Thread 0, Frame 0:
vkCreateImageView(device, pCreateInfo, pAllocator, pView) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkImageViewCreateInfo* = 0000006FC2F88CB0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (15)
        pNext:                          const void* = NULL
        flags:                          VkImageViewCreateFlags = 0
        image:                          VkImage = 0000018D7177B288
        viewType:                       VkImageViewType = VK_IMAGE_VIEW_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_R8G8B8A8_UNORM (37)
        components:                     VkComponentMapping = 0000006FC2F88CD8:
            r:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            g:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            b:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            a:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
        subresourceRange:               VkImageSubresourceRange = 0000006FC2F88CE8:
            aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
            baseMipLevel:                   uint32_t = 0
            levelCount:                     uint32_t = 1
            baseArrayLayer:                 uint32_t = 0
            layerCount:                     uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pView:                          VkImageView* = 0000018D717A7578

Thread 0, Frame 0:
vkCreateImageView(device, pCreateInfo, pAllocator, pView) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkImageViewCreateInfo* = 0000006FC2F88CB0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (15)
        pNext:                          const void* = NULL
        flags:                          VkImageViewCreateFlags = 0
        image:                          VkImage = 0000018D7177E358
        viewType:                       VkImageViewType = VK_IMAGE_VIEW_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_R8G8B8A8_UNORM (37)
        components:                     VkComponentMapping = 0000006FC2F88CD8:
            r:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            g:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            b:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            a:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
        subresourceRange:               VkImageSubresourceRange = 0000006FC2F88CE8:
            aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
            baseMipLevel:                   uint32_t = 0
            levelCount:                     uint32_t = 1
            baseArrayLayer:                 uint32_t = 0
            layerCount:                     uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pView:                          VkImageView* = 0000018D717A7B18

Thread 0, Frame 0:
vkCreateImageView(device, pCreateInfo, pAllocator, pView) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkImageViewCreateInfo* = 0000006FC2F88CB0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (15)
        pNext:                          const void* = NULL
        flags:                          VkImageViewCreateFlags = 0
        image:                          VkImage = 0000018D717A1438
        viewType:                       VkImageViewType = VK_IMAGE_VIEW_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_R8G8B8A8_UNORM (37)
        components:                     VkComponentMapping = 0000006FC2F88CD8:
            r:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            g:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            b:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            a:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
        subresourceRange:               VkImageSubresourceRange = 0000006FC2F88CE8:
            aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
            baseMipLevel:                   uint32_t = 0
            levelCount:                     uint32_t = 1
            baseArrayLayer:                 uint32_t = 0
            layerCount:                     uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pView:                          VkImageView* = 0000018D717A7938

Thread 0, Frame 0:
vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFramebufferCreateInfo* = 0000006FC2F88CA0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (37)
        pNext:                          const void* = NULL
        flags:                          VkFramebufferCreateFlags = 0
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkImageView* = 0000006FC2F88D18
            pAttachments[0]:                const VkImageView = 0000018D717A7578
        width:                          uint32_t = 900
        height:                         uint32_t = 900
        layers:                         uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFramebuffer:                   VkFramebuffer* = 0000018D71694948

Thread 0, Frame 0:
vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFramebufferCreateInfo* = 0000006FC2F88CA0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (37)
        pNext:                          const void* = NULL
        flags:                          VkFramebufferCreateFlags = 0
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkImageView* = 0000006FC2F88D18
            pAttachments[0]:                const VkImageView = 0000018D717A7B18
        width:                          uint32_t = 900
        height:                         uint32_t = 900
        layers:                         uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFramebuffer:                   VkFramebuffer* = 0000018D71635728

Thread 0, Frame 0:
vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFramebufferCreateInfo* = 0000006FC2F88CA0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (37)
        pNext:                          const void* = NULL
        flags:                          VkFramebufferCreateFlags = 0
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkImageView* = 0000006FC2F88D18
            pAttachments[0]:                const VkImageView = 0000018D717A7938
        width:                          uint32_t = 900
        height:                         uint32_t = 900
        layers:                         uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFramebuffer:                   VkFramebuffer* = 0000018D71630BD8

Thread 0, Frame 0:
vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkShaderModuleCreateInfo* = 0000006FC2F891A8:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO (16)
        pNext:                          const void* = NULL
        flags:                          VkShaderModuleCreateFlags = 0
        codeSize:                       size_t = 1184
        pCode:                          const uint32_t* = SHADER DATA
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pShaderModule:                  VkShaderModule* = 0000018D71653EE8

Thread 0, Frame 0:
vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkShaderModuleCreateInfo* = 0000006FC2F891A8:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO (16)
        pNext:                          const void* = NULL
        flags:                          VkShaderModuleCreateFlags = 0
        codeSize:                       size_t = 1380
        pCode:                          const uint32_t* = SHADER DATA
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pShaderModule:                  VkShaderModule* = 0000018D71654768

Thread 0, Frame 0:
vkCreateSampler(device, pCreateInfo, pAllocator, pSampler) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkSamplerCreateInfo* = 0000006FC2F89130:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO (31)
        pNext:                          const void* = NULL
        flags:                          VkSamplerCreateFlags = 0
        magFilter:                      VkFilter = VK_FILTER_LINEAR (1)
        minFilter:                      VkFilter = VK_FILTER_LINEAR (1)
        mipmapMode:                     VkSamplerMipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR (1)
        addressModeU:                   VkSamplerAddressMode = VK_SAMPLER_ADDRESS_MODE_REPEAT (0)
        addressModeV:                   VkSamplerAddressMode = VK_SAMPLER_ADDRESS_MODE_REPEAT (0)
        addressModeW:                   VkSamplerAddressMode = VK_SAMPLER_ADDRESS_MODE_REPEAT (0)
        mipLodBias:                     float = 0
        anisotropyEnable:               VkBool32 = 0
        maxAnisotropy:                  float = 16
        compareEnable:                  VkBool32 = 0
        compareOp:                      VkCompareOp = VK_COMPARE_OP_NEVER (0)
        minLod:                         float = 0
        maxLod:                         float = 0
        borderColor:                    VkBorderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK (0)
        unnormalizedCoordinates:        VkBool32 = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSampler:                       VkSampler* = 0000018D717AAC18

Thread 0, Frame 0:
vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkDescriptorSetLayoutCreateInfo* = 0000006FC2F88F78:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO (32)
        pNext:                          const void* = NULL
        flags:                          VkDescriptorSetLayoutCreateFlags = 0
        bindingCount:                   uint32_t = 2
        pBindings:                      const VkDescriptorSetLayoutBinding* = 0000018D716597B0
            pBindings[0]:                   const VkDescriptorSetLayoutBinding = 0000018D716597B0:
                binding:                        uint32_t = 0
                descriptorType:                 VkDescriptorType = VK_DESCRIPTOR_TYPE_SAMPLER (0)
                descriptorCount:                uint32_t = 1
                stageFlags:                     VkShaderStageFlags = 16 (VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
                pImmutableSamplers:             const VkSampler* = 0000006FC2F8B598
                    pImmutableSamplers[0]:          const VkSampler = 0000018D717AAC18
            pBindings[1]:                   const VkDescriptorSetLayoutBinding = 0000018D716597C8:
                binding:                        uint32_t = 1
                descriptorType:                 VkDescriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE (2)
                descriptorCount:                uint32_t = 1
                stageFlags:                     VkShaderStageFlags = 16 (VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
                pImmutableSamplers:             const VkSampler* = UNUSED
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSetLayout:                     VkDescriptorSetLayout* = 0000018D717AB528

Thread 0, Frame 0:
vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkDescriptorPoolCreateInfo* = 0000006FC2F88FA8:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO (33)
        pNext:                          const void* = NULL
        flags:                          VkDescriptorPoolCreateFlags = 0
        maxSets:                        uint32_t = 1
        poolSizeCount:                  uint32_t = 2
        pPoolSizes:                     const VkDescriptorPoolSize* = 0000018D7176E7C0
            pPoolSizes[0]:                  const VkDescriptorPoolSize = 0000018D7176E7C0:
                type:                           VkDescriptorType = VK_DESCRIPTOR_TYPE_SAMPLER (0)
                descriptorCount:                uint32_t = 1
            pPoolSizes[1]:                  const VkDescriptorPoolSize = 0000018D7176E7C8:
                type:                           VkDescriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE (2)
                descriptorCount:                uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pDescriptorPool:                VkDescriptorPool* = 0000018D717AB798

Thread 0, Frame 0:
vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkPipelineLayoutCreateInfo* = 0000006FC2F89140:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO (30)
        pNext:                          const void* = NULL
        flags:                          VkPipelineLayoutCreateFlags = 0
        setLayoutCount:                 uint32_t = 1
        pSetLayouts:                    const VkDescriptorSetLayout* = 0000018D717ABE60
            pSetLayouts[0]:                 const VkDescriptorSetLayout = 0000018D717AB528
        pushConstantRangeCount:         uint32_t = 1
        pPushConstantRanges:            const VkPushConstantRange* = 0000018D717AC9F0
            pPushConstantRanges[0]:         const VkPushConstantRange = 0000018D717AC9F0:
                stageFlags:                     VkShaderStageFlags = 17 (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
                offset:                         uint32_t = 0
                size:                           uint32_t = 96
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pPipelineLayout:                VkPipelineLayout* = 0000018D717AD8E8

Thread 0, Frame 0:
vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pipelineCache:                  VkPipelineCache = 0000000000000000
    createInfoCount:                uint32_t = 1
    pCreateInfos:                   const VkGraphicsPipelineCreateInfo* = 0000006FC2F88F70
        pCreateInfos[0]:                const VkGraphicsPipelineCreateInfo = 0000006FC2F88F70:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO (28)
            pNext:                          const void* = NULL
            flags:                          VkPipelineCreateFlags = 0
            stageCount:                     uint32_t = 2
            pStages:                        const VkPipelineShaderStageCreateInfo* = 0000018D717A4610
                pStages[0]:                     const VkPipelineShaderStageCreateInfo = 0000018D717A4610:
                    sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO (18)
                    pNext:                          const void* = NULL
                    flags:                          VkPipelineShaderStageCreateFlags = 0
                    stage:                          VkShaderStageFlagBits = 1 (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
                    module:                         VkShaderModule = 0000018D71653EE8
                    pName:                          const char* = "main"
                    pSpecializationInfo:            const VkSpecializationInfo* = 0000006FC2F88678:
                        mapEntryCount:                  uint32_t = 0
                        pMapEntries:                    const VkSpecializationMapEntry* = NULL
                        dataSize:                       size_t = 0
                        pData:                          const void* = NULL
                pStages[1]:                     const VkPipelineShaderStageCreateInfo = 0000018D717A4640:
                    sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO (18)
                    pNext:                          const void* = NULL
                    flags:                          VkPipelineShaderStageCreateFlags = 0
                    stage:                          VkShaderStageFlagBits = 16 (VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
                    module:                         VkShaderModule = 0000018D71654768
                    pName:                          const char* = "main"
                    pSpecializationInfo:            const VkSpecializationInfo* = 0000006FC2F886B8:
                        mapEntryCount:                  uint32_t = 1
                        pMapEntries:                    const VkSpecializationMapEntry* = 0000018D717ABB40
                            pMapEntries[0]:                 const VkSpecializationMapEntry = 0000018D717ABB40:
                                constantID:                     uint32_t = 0
                                offset:                         uint32_t = 0
                                size:                           size_t = 4
                        dataSize:                       size_t = 4
                        pData:                          const void* = 00007FF7FB7F49C8
            pVertexInputState:              const VkPipelineVertexInputStateCreateInfo* = 0000006FC2F88248:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO (19)
                pNext:                          const void* = NULL
                flags:                          VkPipelineVertexInputStateCreateFlags = 0
                vertexBindingDescriptionCount:  uint32_t = 1
                pVertexBindingDescriptions:     const VkVertexInputBindingDescription* = 0000018D7176F710
                    pVertexBindingDescriptions[0]:  const VkVertexInputBindingDescription = 0000018D7176F710:
                        binding:                        uint32_t = 0
                        stride:                         uint32_t = 16
                        inputRate:                      VkVertexInputRate = VK_VERTEX_INPUT_RATE_VERTEX (0)
                vertexAttributeDescriptionCount: uint32_t = 2
                pVertexAttributeDescriptions:   const VkVertexInputAttributeDescription* = 0000018D6B378550
                    pVertexAttributeDescriptions[0]: const VkVertexInputAttributeDescription = 0000018D6B378550:
                        location:                       uint32_t = 0
                        binding:                        uint32_t = 0
                        format:                         VkFormat = VK_FORMAT_R32G32_SFLOAT (103)
                        offset:                         uint32_t = 0
                    pVertexAttributeDescriptions[1]: const VkVertexInputAttributeDescription = 0000018D6B378560:
                        location:                       uint32_t = 1
                        binding:                        uint32_t = 0
                        format:                         VkFormat = VK_FORMAT_R32G32_SFLOAT (103)
                        offset:                         uint32_t = 8
            pInputAssemblyState:            const VkPipelineInputAssemblyStateCreateInfo* = 0000006FC2F88298:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO (20)
                pNext:                          const void* = NULL
                flags:                          VkPipelineInputAssemblyStateCreateFlags = 0
                topology:                       VkPrimitiveTopology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST (3)
                primitiveRestartEnable:         VkBool32 = 0
            pTessellationState:             const VkPipelineTessellationStateCreateInfo* = NULL
            pViewportState:                 const VkPipelineViewportStateCreateInfo* = 0000006FC2F88E38:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO (22)
                pNext:                          const void* = NULL
                flags:                          VkPipelineViewportStateCreateFlags = 0
                viewportCount:                  uint32_t = 1
                pViewports:                     const VkViewport* = UNUSED
                scissorCount:                   uint32_t = 1
                pScissors:                      const VkRect2D* = UNUSED
            pRasterizationState:            const VkPipelineRasterizationStateCreateInfo* = 0000006FC2F88E68:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO (23)
                pNext:                          const void* = NULL
                flags:                          VkPipelineRasterizationStateCreateFlags = 0
                depthClampEnable:               VkBool32 = 0
                rasterizerDiscardEnable:        VkBool32 = 0
                polygonMode:                    VkPolygonMode = VK_POLYGON_MODE_FILL (0)
                cullMode:                       VkCullModeFlags = 0
                frontFace:                      VkFrontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE (0)
                depthBiasEnable:                VkBool32 = 0
                depthBiasConstantFactor:        float = 0
                depthBiasClamp:                 float = 0
                depthBiasSlopeFactor:           float = 0
                lineWidth:                      float = 1
            pMultisampleState:              const VkPipelineMultisampleStateCreateInfo* = 0000006FC2F88EA8:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO (24)
                pNext:                          const void* = NULL
                flags:                          VkPipelineMultisampleStateCreateFlags = 0
                rasterizationSamples:           VkSampleCountFlagBits = 1 (VK_SAMPLE_COUNT_1_BIT)
                sampleShadingEnable:            VkBool32 = 0
                minSampleShading:               float = 0
                pSampleMask:                    const VkSampleMask* = NULL
                alphaToCoverageEnable:          VkBool32 = 0
                alphaToOneEnable:               VkBool32 = 0
            pDepthStencilState:             const VkPipelineDepthStencilStateCreateInfo* = NULL
            pColorBlendState:               const VkPipelineColorBlendStateCreateInfo* = 0000006FC2F88EF8:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO (26)
                pNext:                          const void* = NULL
                flags:                          VkPipelineColorBlendStateCreateFlags = 0
                logicOpEnable:                  VkBool32 = 0
                logicOp:                        VkLogicOp = VK_LOGIC_OP_CLEAR (0)
                attachmentCount:                uint32_t = 1
                pAttachments:                   const VkPipelineColorBlendAttachmentState* = 0000006FC2F88ED8
                    pAttachments[0]:                const VkPipelineColorBlendAttachmentState = 0000006FC2F88ED8:
                        blendEnable:                    VkBool32 = 1
                        srcColorBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA (6)
                        dstColorBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA (7)
                        colorBlendOp:                   VkBlendOp = VK_BLEND_OP_ADD (0)
                        srcAlphaBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_ZERO (0)
                        dstAlphaBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_ZERO (0)
                        alphaBlendOp:                   VkBlendOp = VK_BLEND_OP_ADD (0)
                        colorWriteMask:                 VkColorComponentFlags = 15 (VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT)
                blendConstants:                 float[4] = 0000006FC2F88F20
                    blendConstants[0]:              float = 1
                    blendConstants[1]:              float = 1
                    blendConstants[2]:              float = 1
                    blendConstants[3]:              float = 1
            pDynamicState:                  const VkPipelineDynamicStateCreateInfo* = 0000006FC2F88F50:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO (27)
                pNext:                          const void* = NULL
                flags:                          VkPipelineDynamicStateCreateFlags = 0
                dynamicStateCount:              uint32_t = 2
                pDynamicStates:                 const VkDynamicState* = 0000018D717AC680
                    pDynamicStates[0]:              const VkDynamicState = VK_DYNAMIC_STATE_VIEWPORT (0)
                    pDynamicStates[1]:              const VkDynamicState = VK_DYNAMIC_STATE_SCISSOR (1)
            layout:                         VkPipelineLayout = 0000018D717AD8E8
            renderPass:                     VkRenderPass = 0000018D6B2D51D8
            subpass:                        uint32_t = 0
            basePipelineHandle:             VkPipeline = 0000000000000000
            basePipelineIndex:              int32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pPipelines:                     VkPipeline* = 0000006FC2F882D8
        pPipelines[0]:                  VkPipeline = 0000018D717ADD98

Thread 0, Frame 0:
vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkCommandPoolCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO (39)
        pNext:                          const void* = NULL
        flags:                          VkCommandPoolCreateFlags = 3 (VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT)
        queueFamilyIndex:               uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pCommandPool:                   VkCommandPool* = 0000018D717D62B8

Thread 0, Frame 0:
vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pAllocateInfo:                  const VkCommandBufferAllocateInfo* = 0000006FC2F89288:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (40)
        pNext:                          const void* = NULL
        commandPool:                    VkCommandPool = 0000018D717D62B8
        level:                          VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_PRIMARY (0)
        commandBufferCount:             uint32_t = 1
    pCommandBuffers:                VkCommandBuffer* = 0000018D717ABEB0
        pCommandBuffers[0]:             VkCommandBuffer = 0000018D717F60C8

Thread 0, Frame 0:
vkCreateFence(device, pCreateInfo, pAllocator, pFence) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFenceCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (8)
        pNext:                          const void* = NULL
        flags:                          VkFenceCreateFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFence:                         VkFence* = 0000018D6B382E48

Thread 0, Frame 0:
vkCreateImage(device, pCreateInfo, pAllocator, pImage) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkImageCreateInfo* = 0000006FC2F884C8:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO (14)
        pNext:                          const void* = NULL
        flags:                          VkImageCreateFlags = 0
        imageType:                      VkImageType = VK_IMAGE_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_R8G8B8A8_SRGB (43)
        extent:                         VkExtent3D = 0000006FC2F884E4:
            width:                          uint32_t = 1024
            height:                         uint32_t = 512
            depth:                          uint32_t = 1
        mipLevels:                      uint32_t = 1
        arrayLayers:                    uint32_t = 1
        samples:                        VkSampleCountFlagBits = 1 (VK_SAMPLE_COUNT_1_BIT)
        tiling:                         VkImageTiling = VK_IMAGE_TILING_OPTIMAL (0)
        usage:                          VkImageUsageFlags = 6 (VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT)
        sharingMode:                    VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 1
        pQueueFamilyIndices:            const uint32_t* = UNUSED
        initialLayout:                  VkImageLayout = VK_IMAGE_LAYOUT_UNDEFINED (0)
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pImage:                         VkImage* = 0000018D717D2298

Thread 0, Frame 0:
vkGetImageMemoryRequirements(device, image, pMemoryRequirements) returns void:
    device:                         VkDevice = 0000018D6B18B040
    image:                          VkImage = 0000018D717D2298
    pMemoryRequirements:            VkMemoryRequirements* = 0000006FC2F882F8:
        size:                           VkDeviceSize = 2097152
        alignment:                      VkDeviceSize = 4096
        memoryTypeBits:                 uint32_t = 3

Thread 0, Frame 0:
vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pAllocateInfo:                  const VkMemoryAllocateInfo* = 0000006FC2F88118:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (5)
        pNext:                          const void* = NULL
        allocationSize:                 VkDeviceSize = 2097152
        memoryTypeIndex:                uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pMemory:                        VkDeviceMemory* = 0000018D68832868

Thread 0, Frame 0:
vkBindImageMemory(device, image, memory, memoryOffset) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    image:                          VkImage = 0000018D717D2298
    memory:                         VkDeviceMemory = 0000018D68832868
    memoryOffset:                   VkDeviceSize = 0

Thread 0, Frame 0:
vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkBufferCreateInfo* = 0000006FC2F88078:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO (12)
        pNext:                          const void* = NULL
        flags:                          VkBufferCreateFlags = 0
        size:                           VkDeviceSize = 2097152
        usage:                          VkBufferUsageFlags = 1 (VK_BUFFER_USAGE_TRANSFER_SRC_BIT)
        sharingMode:                    VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 1
        pQueueFamilyIndices:            const uint32_t* = UNUSED
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pBuffer:                        VkBuffer* = 0000018D717E9E38

Thread 0, Frame 0:
vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements) returns void:
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D717E9E38
    pMemoryRequirements:            VkMemoryRequirements* = 0000006FC2F87ED8:
        size:                           VkDeviceSize = 2097152
        alignment:                      VkDeviceSize = 32
        memoryTypeBits:                 uint32_t = 3

Thread 0, Frame 0:
vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pAllocateInfo:                  const VkMemoryAllocateInfo* = 0000006FC2F87CF8:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (5)
        pNext:                          const void* = NULL
        allocationSize:                 VkDeviceSize = 2097152
        memoryTypeIndex:                uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pMemory:                        VkDeviceMemory* = 0000018D68832C28

Thread 0, Frame 0:
vkBindBufferMemory(device, buffer, memory, memoryOffset) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D717E9E38
    memory:                         VkDeviceMemory = 0000018D68832C28
    memoryOffset:                   VkDeviceSize = 0

Thread 0, Frame 0:
vkMapMemory(device, memory, offset, size, flags, ppData) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    memory:                         VkDeviceMemory = 0000018D68832C28
    offset:                         VkDeviceSize = 0
    size:                           VkDeviceSize = 2097152
    flags:                          VkMemoryMapFlags = 0
    ppData:                         void** = 0000018D73370000

Thread 0, Frame 0:
vkUnmapMemory(device, memory) returns void:
    device:                         VkDevice = 0000018D6B18B040
    memory:                         VkDeviceMemory = 0000018D68832C28

Thread 0, Frame 0:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC2F88638:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 1 (VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT)
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 0:
vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8
    srcStageMask:                   VkPipelineStageFlags = 1 (VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT)
    dstStageMask:                   VkPipelineStageFlags = 4096 (VK_PIPELINE_STAGE_TRANSFER_BIT)
    dependencyFlags:                VkDependencyFlags = 0
    memoryBarrierCount:             uint32_t = 0
    pMemoryBarriers:                const VkMemoryBarrier* = NULL
    bufferMemoryBarrierCount:       uint32_t = 0
    pBufferMemoryBarriers:          const VkBufferMemoryBarrier* = NULL
    imageMemoryBarrierCount:        uint32_t = 1
    pImageMemoryBarriers:           const VkImageMemoryBarrier* = 0000006FC2F88680
        pImageMemoryBarriers[0]:        const VkImageMemoryBarrier = 0000006FC2F88680:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER (45)
            pNext:                          const void* = NULL
            srcAccessMask:                  VkAccessFlags = 0
            dstAccessMask:                  VkAccessFlags = 4096 (VK_ACCESS_TRANSFER_WRITE_BIT)
            oldLayout:                      VkImageLayout = VK_IMAGE_LAYOUT_UNDEFINED (0)
            newLayout:                      VkImageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL (7)
            srcQueueFamilyIndex:            uint32_t = 0
            dstQueueFamilyIndex:            uint32_t = 0
            image:                          VkImage = 0000018D717D2298
            subresourceRange:               VkImageSubresourceRange = 0000006FC2F886B0:
                aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
                baseMipLevel:                   uint32_t = 0
                levelCount:                     uint32_t = 1
                baseArrayLayer:                 uint32_t = 0
                layerCount:                     uint32_t = 1

Thread 0, Frame 0:
vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8
    srcBuffer:                      VkBuffer = 0000018D717E9E38
    dstImage:                       VkImage = 0000018D717D2298
    dstImageLayout:                 VkImageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL (7)
    regionCount:                    uint32_t = 1
    pRegions:                       const VkBufferImageCopy* = 0000006FC2F886E8
        pRegions[0]:                    const VkBufferImageCopy = 0000006FC2F886E8:
            bufferOffset:                   VkDeviceSize = 0
            bufferRowLength:                uint32_t = 0
            bufferImageHeight:              uint32_t = 0
            imageSubresource:               VkImageSubresourceLayers = 0000006FC2F886F8:
                aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
                mipLevel:                       uint32_t = 0
                baseArrayLayer:                 uint32_t = 0
                layerCount:                     uint32_t = 1
            imageOffset:                    VkOffset3D = 0000006FC2F88708:
                x:                              int32_t = 0
                y:                              int32_t = 0
                z:                              int32_t = 0
            imageExtent:                    VkExtent3D = 0000006FC2F88714:
                width:                          uint32_t = 1024
                height:                         uint32_t = 512
                depth:                          uint32_t = 1

Thread 0, Frame 0:
vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8
    srcStageMask:                   VkPipelineStageFlags = 4096 (VK_PIPELINE_STAGE_TRANSFER_BIT)
    dstStageMask:                   VkPipelineStageFlags = 128 (VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT)
    dependencyFlags:                VkDependencyFlags = 0
    memoryBarrierCount:             uint32_t = 0
    pMemoryBarriers:                const VkMemoryBarrier* = NULL
    bufferMemoryBarrierCount:       uint32_t = 0
    pBufferMemoryBarriers:          const VkBufferMemoryBarrier* = NULL
    imageMemoryBarrierCount:        uint32_t = 1
    pImageMemoryBarriers:           const VkImageMemoryBarrier* = 0000006FC2F88740
        pImageMemoryBarriers[0]:        const VkImageMemoryBarrier = 0000006FC2F88740:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER (45)
            pNext:                          const void* = NULL
            srcAccessMask:                  VkAccessFlags = 4096 (VK_ACCESS_TRANSFER_WRITE_BIT)
            dstAccessMask:                  VkAccessFlags = 32 (VK_ACCESS_SHADER_READ_BIT)
            oldLayout:                      VkImageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL (7)
            newLayout:                      VkImageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL (5)
            srcQueueFamilyIndex:            uint32_t = 0
            dstQueueFamilyIndex:            uint32_t = 0
            image:                          VkImage = 0000018D717D2298
            subresourceRange:               VkImageSubresourceRange = 0000006FC2F88770:
                aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
                baseMipLevel:                   uint32_t = 0
                levelCount:                     uint32_t = 1
                baseArrayLayer:                 uint32_t = 0
                layerCount:                     uint32_t = 1

Thread 0, Frame 0:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8

Thread 0, Frame 0:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC2F887B0
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC2F887B0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC2F88F70
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D717F60C8
            signalSemaphoreCount:           uint32_t = 0
            pSignalSemaphores:              const VkSemaphore* = NULL
    fence:                          VkFence = 0000018D6B382E48

Thread 0, Frame 0:
vkCreateImageView(device, pCreateInfo, pAllocator, pView) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkImageViewCreateInfo* = 0000006FC2F88840:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (15)
        pNext:                          const void* = NULL
        flags:                          VkImageViewCreateFlags = 0
        image:                          VkImage = 0000018D717D2298
        viewType:                       VkImageViewType = VK_IMAGE_VIEW_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_R8G8B8A8_SRGB (43)
        components:                     VkComponentMapping = 0000006FC2F88868:
            r:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            g:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            b:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            a:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
        subresourceRange:               VkImageSubresourceRange = 0000006FC2F88878:
            aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
            baseMipLevel:                   uint32_t = 0
            levelCount:                     uint32_t = 1
            baseArrayLayer:                 uint32_t = 0
            layerCount:                     uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pView:                          VkImageView* = 0000018D717A80B8

Thread 0, Frame 0:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC2F88F78
        pFences[0]:                     const VkFence = 0000018D6B382E48
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 0:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC2F88F78
        pFences[0]:                     const VkFence = 0000018D6B382E48

Thread 0, Frame 0:
vkDestroyBuffer(device, buffer, pAllocator) returns void:
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D717E9E38
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 0:
vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkBufferCreateInfo* = 0000006FC2F88A88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO (12)
        pNext:                          const void* = NULL
        flags:                          VkBufferCreateFlags = 0
        size:                           VkDeviceSize = 96
        usage:                          VkBufferUsageFlags = 1 (VK_BUFFER_USAGE_TRANSFER_SRC_BIT)
        sharingMode:                    VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 1
        pQueueFamilyIndices:            const uint32_t* = UNUSED
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pBuffer:                        VkBuffer* = 0000018D717E9E38

Thread 0, Frame 0:
vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements) returns void:
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D717E9E38
    pMemoryRequirements:            VkMemoryRequirements* = 0000006FC2F888E8:
        size:                           VkDeviceSize = 96
        alignment:                      VkDeviceSize = 32
        memoryTypeBits:                 uint32_t = 3

Thread 0, Frame 0:
vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pAllocateInfo:                  const VkMemoryAllocateInfo* = 0000006FC2F88708:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (5)
        pNext:                          const void* = NULL
        allocationSize:                 VkDeviceSize = 96
        memoryTypeIndex:                uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pMemory:                        VkDeviceMemory* = 0000018D68833498

Thread 0, Frame 0:
vkBindBufferMemory(device, buffer, memory, memoryOffset) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D717E9E38
    memory:                         VkDeviceMemory = 0000018D68833498
    memoryOffset:                   VkDeviceSize = 0

Thread 0, Frame 0:
vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkBufferCreateInfo* = 0000006FC2F88A88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO (12)
        pNext:                          const void* = NULL
        flags:                          VkBufferCreateFlags = 0
        size:                           VkDeviceSize = 96
        usage:                          VkBufferUsageFlags = 130 (VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT)
        sharingMode:                    VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 1
        pQueueFamilyIndices:            const uint32_t* = UNUSED
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pBuffer:                        VkBuffer* = 0000018D71807E78

Thread 0, Frame 0:
vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements) returns void:
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D71807E78
    pMemoryRequirements:            VkMemoryRequirements* = 0000006FC2F888E8:
        size:                           VkDeviceSize = 96
        alignment:                      VkDeviceSize = 32
        memoryTypeBits:                 uint32_t = 3

Thread 0, Frame 0:
vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pAllocateInfo:                  const VkMemoryAllocateInfo* = 0000006FC2F88708:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (5)
        pNext:                          const void* = NULL
        allocationSize:                 VkDeviceSize = 96
        memoryTypeIndex:                uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pMemory:                        VkDeviceMemory* = 0000018D688333A8

Thread 0, Frame 0:
vkBindBufferMemory(device, buffer, memory, memoryOffset) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D71807E78
    memory:                         VkDeviceMemory = 0000018D688333A8
    memoryOffset:                   VkDeviceSize = 0

Thread 0, Frame 0:
vkMapMemory(device, memory, offset, size, flags, ppData) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    memory:                         VkDeviceMemory = 0000018D68833498
    offset:                         VkDeviceSize = 0
    size:                           VkDeviceSize = 96
    flags:                          VkMemoryMapFlags = 0
    ppData:                         void** = 0000018D6F5B0000

Thread 0, Frame 0:
vkUnmapMemory(device, memory) returns void:
    device:                         VkDevice = 0000018D6B18B040
    memory:                         VkDeviceMemory = 0000018D68833498

Thread 0, Frame 0:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC2F88C88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 1 (VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT)
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 0:
vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8
    srcBuffer:                      VkBuffer = 0000018D717E9E38
    dstBuffer:                      VkBuffer = 0000018D71807E78
    regionCount:                    uint32_t = 1
    pRegions:                       const VkBufferCopy* = 0000006FC2F88FC8
        pRegions[0]:                    const VkBufferCopy = 0000006FC2F88FC8:
            srcOffset:                      VkDeviceSize = 0
            dstOffset:                      VkDeviceSize = 0
            size:                           VkDeviceSize = 96

Thread 0, Frame 0:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D717F60C8

Thread 0, Frame 0:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC2F88CD0
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC2F88CD0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC2F88E30
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D717F60C8
            signalSemaphoreCount:           uint32_t = 0
            pSignalSemaphores:              const VkSemaphore* = NULL
    fence:                          VkFence = 0000018D6B382E48

Thread 0, Frame 0:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC2F8CC48
        pFences[0]:                     const VkFence = 0000018D6B382E48
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 0:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC2F8CC48
        pFences[0]:                     const VkFence = 0000018D6B382E48

Thread 0, Frame 0:
vkDestroyBuffer(device, buffer, pAllocator) returns void:
    device:                         VkDevice = 0000018D6B18B040
    buffer:                         VkBuffer = 0000018D717E9E38
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 0:
vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pAllocateInfo:                  const VkDescriptorSetAllocateInfo* = 0000006FC2F8C778:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO (34)
        pNext:                          const void* = NULL
        descriptorPool:                 VkDescriptorPool = 0000018D717AB798
        descriptorSetCount:             uint32_t = 1
        pSetLayouts:                    const VkDescriptorSetLayout* = 0000018D717ACA90
            pSetLayouts[0]:                 const VkDescriptorSetLayout = 0000018D717AB528
    pDescriptorSets:                VkDescriptorSet* = 0000018D717AC4F0
        pDescriptorSets[0]:             VkDescriptorSet = 0000018D6B378A68

Thread 0, Frame 0:
vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies) returns void:
    device:                         VkDevice = 0000018D6B18B040
    descriptorWriteCount:           uint32_t = 1
    pDescriptorWrites:              const VkWriteDescriptorSet* = 0000006FC2F8A1F0
        pDescriptorWrites[0]:           const VkWriteDescriptorSet = 0000006FC2F8A1F0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET (35)
            pNext:                          const void* = NULL
            dstSet:                         VkDescriptorSet = 0000018D6B378A68
            dstBinding:                     uint32_t = 1
            dstArrayElement:                uint32_t = 0
            descriptorCount:                uint32_t = 1
            descriptorType:                 VkDescriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE (2)
            pImageInfo:                     const VkDescriptorImageInfo* = 0000018D6B3773B0
                pImageInfo[0]:                  const VkDescriptorImageInfo = 0000018D6B3773B0:
                    sampler:                        VkSampler = 0000000000000000
                    imageView:                      VkImageView = 0000018D717A80B8
                    imageLayout:                    VkImageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL (5)
            pBufferInfo:                    const VkDescriptorBufferInfo* = UNUSED
            pTexelBufferView:               const VkBufferView* = UNUSED
    descriptorCopyCount:            uint32_t = 0
    pDescriptorCopies:              const VkCopyDescriptorSet* = NULL

Thread 0, Frame 0:
vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkCommandPoolCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO (39)
        pNext:                          const void* = NULL
        flags:                          VkCommandPoolCreateFlags = 2 (VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT)
        queueFamilyIndex:               uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pCommandPool:                   VkCommandPool* = 0000018D71808038

Thread 0, Frame 0:
vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pAllocateInfo:                  const VkCommandBufferAllocateInfo* = 0000006FC2F89288:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (40)
        pNext:                          const void* = NULL
        commandPool:                    VkCommandPool = 0000018D71808038
        level:                          VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_PRIMARY (0)
        commandBufferCount:             uint32_t = 3
    pCommandBuffers:                VkCommandBuffer* = 0000018D6B377B90
        pCommandBuffers[0]:             VkCommandBuffer = 0000018D71808458
        pCommandBuffers[1]:             VkCommandBuffer = 0000018D71838D28
        pCommandBuffers[2]:             VkCommandBuffer = 0000018D718415D8

Thread 0, Frame 0:
vkCreateFence(device, pCreateInfo, pAllocator, pFence) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFenceCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (8)
        pNext:                          const void* = NULL
        flags:                          VkFenceCreateFlags = 1 (VK_FENCE_CREATE_SIGNALED_BIT)
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFence:                         VkFence* = 0000018D6B382ED8

Thread 0, Frame 0:
vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkSemaphoreCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO (9)
        pNext:                          const void* = NULL
        flags:                          VkSemaphoreCreateFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSemaphore:                     VkSemaphore* = 0000018D6B382938

Thread 0, Frame 0:
vkCreateFence(device, pCreateInfo, pAllocator, pFence) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFenceCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (8)
        pNext:                          const void* = NULL
        flags:                          VkFenceCreateFlags = 1 (VK_FENCE_CREATE_SIGNALED_BIT)
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFence:                         VkFence* = 0000018D6B381FA8

Thread 0, Frame 0:
vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkSemaphoreCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO (9)
        pNext:                          const void* = NULL
        flags:                          VkSemaphoreCreateFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSemaphore:                     VkSemaphore* = 0000018D6B3829C8

Thread 0, Frame 0:
vkCreateFence(device, pCreateInfo, pAllocator, pFence) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFenceCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (8)
        pNext:                          const void* = NULL
        flags:                          VkFenceCreateFlags = 1 (VK_FENCE_CREATE_SIGNALED_BIT)
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFence:                         VkFence* = 0000018D6B382A58

Thread 0, Frame 0:
vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkSemaphoreCreateInfo* = 0000006FC2F89258:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO (9)
        pNext:                          const void* = NULL
        flags:                          VkSemaphoreCreateFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSemaphore:                     VkSemaphore* = 0000018D6B382278

Thread 1, Frame 0:
vkCreateFence(device, pCreateInfo, pAllocator, pFence) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    pCreateInfo:                    const VkFenceCreateInfo* = 0000006FC3BFE718:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (8)
        pNext:                          const void* = NULL
        flags:                          VkFenceCreateFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFence:                         VkFence* = 0000018D6B383088

Thread 1, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 0:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 0:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382ED8
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 0:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382ED8

Thread 1, Frame 0:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC3BFEC88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 1, Frame 0:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0000006FC3BFECD0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        framebuffer:                    VkFramebuffer = 0000018D71694948
        renderArea:                     VkRect2D = 0000006FC3BFECF0:
            offset:                         VkOffset2D = 0000006FC3BFECF0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFECF8:
                width:                          uint32_t = 900
                height:                         uint32_t = 900
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0000006FC2F8CDAC
            pClearValues[0]:                const VkClearValue = 0000006FC2F8CDAC (Union):
                color:                          VkClearColorValue = 0000006FC2F8CDAC (Union):
                    float32:                        float[4] = 0000006FC2F8CDAC
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 0
                    int32:                          int32_t[4] = 0000006FC2F8CDAC
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 0
                    uint32:                         uint32_t[4] = 0000006FC2F8CDAC
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 0
                depthStencil:                   VkClearDepthStencilValue = 0000006FC2F8CDAC:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 1, Frame 0:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0000018D717ADD98

Thread 1, Frame 0:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0000006FC3BFEC28
        pViewports[0]:                  const VkViewport = 0000006FC3BFEC28:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 900
            height:                         float = 900
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 1, Frame 0:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0000006FC3BFEC58
        pScissors[0]:                   const VkRect2D = 0000006FC3BFEC58:
            offset:                         VkOffset2D = 0000006FC3BFEC58:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFEC60:
                width:                          uint32_t = 900
                height:                         uint32_t = 900

Thread 1, Frame 0:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0000006FC3BFEB88
        pBuffers[0]:                    const VkBuffer = 0000018D71807E78
    pOffsets:                       const VkDeviceSize* = 0000006FC3BFED28
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 1, Frame 0:
vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    firstSet:                       uint32_t = 0
    descriptorSetCount:             uint32_t = 1
    pDescriptorSets:                const VkDescriptorSet* = 0000006FC2F8CD10
        pDescriptorSets[0]:             const VkDescriptorSet = 0000018D6B378A68
    dynamicOffsetCount:             uint32_t = 0
    pDynamicOffsets:                const uint32_t* = NULL

Thread 1, Frame 0:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458

Thread 1, Frame 0:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71808458

Thread 1, Frame 0:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 0:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088

Thread 1, Frame 0:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC3BFED70
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC3BFED70:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC3BFEB68
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D71808458
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0000006FC3BFEBC8
                pSignalSemaphores[0]:           const VkSemaphore = 0000018D6B382938
    fence:                          VkFence = 0000018D6B382ED8

Thread 1, Frame 0:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    pPresentInfo:                   const VkPresentInfoKHR* = 0000006FC3BFEE00:
        sType:                          VkStructureType = UNKNOWN (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0000006FC3BFEBC8
            pWaitSemaphores[0]:             const VkSemaphore = 0000018D6B382938
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0000006FC3BFEA88
            pSwapchains[0]:                 const VkSwapchainKHR = 0000018D6B185FE8
        pImageIndices:                  const uint32_t* = 0000006FC2F8CDA8
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 1, Frame 1:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 1:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 1:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B381FA8
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 1:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B381FA8

Thread 1, Frame 1:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC3BFEC88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 1, Frame 1:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0000006FC3BFECD0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        framebuffer:                    VkFramebuffer = 0000018D71635728
        renderArea:                     VkRect2D = 0000006FC3BFECF0:
            offset:                         VkOffset2D = 0000006FC3BFECF0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFECF8:
                width:                          uint32_t = 900
                height:                         uint32_t = 900
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0000006FC2F8CDAC
            pClearValues[0]:                const VkClearValue = 0000006FC2F8CDAC (Union):
                color:                          VkClearColorValue = 0000006FC2F8CDAC (Union):
                    float32:                        float[4] = 0000006FC2F8CDAC
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 0
                    int32:                          int32_t[4] = 0000006FC2F8CDAC
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 0
                    uint32:                         uint32_t[4] = 0000006FC2F8CDAC
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 0
                depthStencil:                   VkClearDepthStencilValue = 0000006FC2F8CDAC:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 1, Frame 1:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0000018D717ADD98

Thread 1, Frame 1:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0000006FC3BFEC28
        pViewports[0]:                  const VkViewport = 0000006FC3BFEC28:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 900
            height:                         float = 900
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 1, Frame 1:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0000006FC3BFEC58
        pScissors[0]:                   const VkRect2D = 0000006FC3BFEC58:
            offset:                         VkOffset2D = 0000006FC3BFEC58:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFEC60:
                width:                          uint32_t = 900
                height:                         uint32_t = 900

Thread 1, Frame 1:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0000006FC3BFEB88
        pBuffers[0]:                    const VkBuffer = 0000018D71807E78
    pOffsets:                       const VkDeviceSize* = 0000006FC3BFED28
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 1, Frame 1:
vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    firstSet:                       uint32_t = 0
    descriptorSetCount:             uint32_t = 1
    pDescriptorSets:                const VkDescriptorSet* = 0000006FC2F8CD10
        pDescriptorSets[0]:             const VkDescriptorSet = 0000018D6B378A68
    dynamicOffsetCount:             uint32_t = 0
    pDynamicOffsets:                const uint32_t* = NULL

Thread 1, Frame 1:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28

Thread 1, Frame 1:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28

Thread 1, Frame 1:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 1:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088

Thread 1, Frame 1:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC3BFED70
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC3BFED70:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC3BFEB68
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D71838D28
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0000006FC3BFEBC8
                pSignalSemaphores[0]:           const VkSemaphore = 0000018D6B3829C8
    fence:                          VkFence = 0000018D6B381FA8

Thread 1, Frame 1:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    pPresentInfo:                   const VkPresentInfoKHR* = 0000006FC3BFEE00:
        sType:                          VkStructureType = UNKNOWN (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0000006FC3BFEBC8
            pWaitSemaphores[0]:             const VkSemaphore = 0000018D6B3829C8
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0000006FC3BFEA88
            pSwapchains[0]:                 const VkSwapchainKHR = 0000018D6B185FE8
        pImageIndices:                  const uint32_t* = 0000006FC2F8CDA8
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 1, Frame 2:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 2:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 2

Thread 1, Frame 2:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382A58
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 2:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382A58

Thread 1, Frame 2:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC3BFEC88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 1, Frame 2:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0000006FC3BFECD0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        framebuffer:                    VkFramebuffer = 0000018D71630BD8
        renderArea:                     VkRect2D = 0000006FC3BFECF0:
            offset:                         VkOffset2D = 0000006FC3BFECF0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFECF8:
                width:                          uint32_t = 900
                height:                         uint32_t = 900
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0000006FC2F8CDAC
            pClearValues[0]:                const VkClearValue = 0000006FC2F8CDAC (Union):
                color:                          VkClearColorValue = 0000006FC2F8CDAC (Union):
                    float32:                        float[4] = 0000006FC2F8CDAC
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 0
                    int32:                          int32_t[4] = 0000006FC2F8CDAC
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 0
                    uint32:                         uint32_t[4] = 0000006FC2F8CDAC
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 0
                depthStencil:                   VkClearDepthStencilValue = 0000006FC2F8CDAC:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 1, Frame 2:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0000018D717ADD98

Thread 1, Frame 2:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0000006FC3BFEC28
        pViewports[0]:                  const VkViewport = 0000006FC3BFEC28:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 900
            height:                         float = 900
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 1, Frame 2:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0000006FC3BFEC58
        pScissors[0]:                   const VkRect2D = 0000006FC3BFEC58:
            offset:                         VkOffset2D = 0000006FC3BFEC58:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFEC60:
                width:                          uint32_t = 900
                height:                         uint32_t = 900

Thread 1, Frame 2:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0000006FC3BFEB88
        pBuffers[0]:                    const VkBuffer = 0000018D71807E78
    pOffsets:                       const VkDeviceSize* = 0000006FC3BFED28
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 1, Frame 2:
vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    firstSet:                       uint32_t = 0
    descriptorSetCount:             uint32_t = 1
    pDescriptorSets:                const VkDescriptorSet* = 0000006FC2F8CD10
        pDescriptorSets[0]:             const VkDescriptorSet = 0000018D6B378A68
    dynamicOffsetCount:             uint32_t = 0
    pDynamicOffsets:                const uint32_t* = NULL

Thread 1, Frame 2:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8

Thread 1, Frame 2:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8

Thread 1, Frame 2:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 2:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088

Thread 1, Frame 2:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC3BFED70
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC3BFED70:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC3BFEB68
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D718415D8
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0000006FC3BFEBC8
                pSignalSemaphores[0]:           const VkSemaphore = 0000018D6B382278
    fence:                          VkFence = 0000018D6B382A58

Thread 1, Frame 2:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    pPresentInfo:                   const VkPresentInfoKHR* = 0000006FC3BFEE00:
        sType:                          VkStructureType = UNKNOWN (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0000006FC3BFEBC8
            pWaitSemaphores[0]:             const VkSemaphore = 0000018D6B382278
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0000006FC3BFEA88
            pSwapchains[0]:                 const VkSwapchainKHR = 0000018D6B185FE8
        pImageIndices:                  const uint32_t* = 0000006FC2F8CDA8
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 1, Frame 3:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 3:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 3:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382ED8
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 3:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382ED8

Thread 1, Frame 3:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC3BFEC88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 1, Frame 3:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0000006FC3BFECD0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        framebuffer:                    VkFramebuffer = 0000018D71694948
        renderArea:                     VkRect2D = 0000006FC3BFECF0:
            offset:                         VkOffset2D = 0000006FC3BFECF0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFECF8:
                width:                          uint32_t = 900
                height:                         uint32_t = 900
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0000006FC2F8CDAC
            pClearValues[0]:                const VkClearValue = 0000006FC2F8CDAC (Union):
                color:                          VkClearColorValue = 0000006FC2F8CDAC (Union):
                    float32:                        float[4] = 0000006FC2F8CDAC
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 0
                    int32:                          int32_t[4] = 0000006FC2F8CDAC
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 0
                    uint32:                         uint32_t[4] = 0000006FC2F8CDAC
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 0
                depthStencil:                   VkClearDepthStencilValue = 0000006FC2F8CDAC:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 1, Frame 3:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0000018D717ADD98

Thread 1, Frame 3:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0000006FC3BFEC28
        pViewports[0]:                  const VkViewport = 0000006FC3BFEC28:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 900
            height:                         float = 900
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 1, Frame 3:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0000006FC3BFEC58
        pScissors[0]:                   const VkRect2D = 0000006FC3BFEC58:
            offset:                         VkOffset2D = 0000006FC3BFEC58:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFEC60:
                width:                          uint32_t = 900
                height:                         uint32_t = 900

Thread 1, Frame 3:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0000006FC3BFEB88
        pBuffers[0]:                    const VkBuffer = 0000018D71807E78
    pOffsets:                       const VkDeviceSize* = 0000006FC3BFED28
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 1, Frame 3:
vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    firstSet:                       uint32_t = 0
    descriptorSetCount:             uint32_t = 1
    pDescriptorSets:                const VkDescriptorSet* = 0000006FC2F8CD10
        pDescriptorSets[0]:             const VkDescriptorSet = 0000018D6B378A68
    dynamicOffsetCount:             uint32_t = 0
    pDynamicOffsets:                const uint32_t* = NULL

Thread 1, Frame 3:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71808458

Thread 1, Frame 3:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71808458

Thread 1, Frame 3:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 3:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088

Thread 1, Frame 3:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC3BFED70
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC3BFED70:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC3BFEB68
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D71808458
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0000006FC3BFEBC8
                pSignalSemaphores[0]:           const VkSemaphore = 0000018D6B382938
    fence:                          VkFence = 0000018D6B382ED8

Thread 1, Frame 3:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    pPresentInfo:                   const VkPresentInfoKHR* = 0000006FC3BFEE00:
        sType:                          VkStructureType = UNKNOWN (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0000006FC3BFEBC8
            pWaitSemaphores[0]:             const VkSemaphore = 0000018D6B382938
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0000006FC3BFEA88
            pSwapchains[0]:                 const VkSwapchainKHR = 0000018D6B185FE8
        pImageIndices:                  const uint32_t* = 0000006FC2F8CDA8
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 0

Thread 1, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 4:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B381FA8
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 4:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B381FA8

Thread 1, Frame 4:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC3BFEC88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 1, Frame 4:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0000006FC3BFECD0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        framebuffer:                    VkFramebuffer = 0000018D71635728
        renderArea:                     VkRect2D = 0000006FC3BFECF0:
            offset:                         VkOffset2D = 0000006FC3BFECF0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFECF8:
                width:                          uint32_t = 900
                height:                         uint32_t = 900
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0000006FC2F8CDAC
            pClearValues[0]:                const VkClearValue = 0000006FC2F8CDAC (Union):
                color:                          VkClearColorValue = 0000006FC2F8CDAC (Union):
                    float32:                        float[4] = 0000006FC2F8CDAC
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 0
                    int32:                          int32_t[4] = 0000006FC2F8CDAC
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 0
                    uint32:                         uint32_t[4] = 0000006FC2F8CDAC
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 0
                depthStencil:                   VkClearDepthStencilValue = 0000006FC2F8CDAC:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 1, Frame 4:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0000018D717ADD98

Thread 1, Frame 4:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0000006FC3BFEC28
        pViewports[0]:                  const VkViewport = 0000006FC3BFEC28:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 900
            height:                         float = 900
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 1, Frame 4:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0000006FC3BFEC58
        pScissors[0]:                   const VkRect2D = 0000006FC3BFEC58:
            offset:                         VkOffset2D = 0000006FC3BFEC58:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFEC60:
                width:                          uint32_t = 900
                height:                         uint32_t = 900

Thread 1, Frame 4:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0000006FC3BFEB88
        pBuffers[0]:                    const VkBuffer = 0000018D71807E78
    pOffsets:                       const VkDeviceSize* = 0000006FC3BFED28
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 1, Frame 4:
vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    firstSet:                       uint32_t = 0
    descriptorSetCount:             uint32_t = 1
    pDescriptorSets:                const VkDescriptorSet* = 0000006FC2F8CD10
        pDescriptorSets[0]:             const VkDescriptorSet = 0000018D6B378A68
    dynamicOffsetCount:             uint32_t = 0
    pDynamicOffsets:                const uint32_t* = NULL

Thread 1, Frame 4:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28

Thread 1, Frame 4:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D71838D28

Thread 1, Frame 4:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 4:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088

Thread 1, Frame 4:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC3BFED70
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC3BFED70:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC3BFEB68
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D71838D28
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0000006FC3BFEBC8
                pSignalSemaphores[0]:           const VkSemaphore = 0000018D6B3829C8
    fence:                          VkFence = 0000018D6B381FA8

Thread 1, Frame 4:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    pPresentInfo:                   const VkPresentInfoKHR* = 0000006FC3BFEE00:
        sType:                          VkStructureType = UNKNOWN (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0000006FC3BFEBC8
            pWaitSemaphores[0]:             const VkSemaphore = 0000018D6B3829C8
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0000006FC3BFEA88
            pSwapchains[0]:                 const VkSwapchainKHR = 0000018D6B185FE8
        pImageIndices:                  const uint32_t* = 0000006FC2F8CDA8
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_NOT_READY (1):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 1

Thread 1, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0000018D6B17B2A0
    surface:                        VkSurfaceKHR = 0000018D6B16BD40
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0000006FC3BFE7F8:
        minImageCount:                  uint32_t = 2
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0000006FC3BFE800:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        minImageExtent:                 VkExtent2D = 0000006FC3BFE808:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageExtent:                 VkExtent2D = 0000006FC3BFE810:
            width:                          uint32_t = 900
            height:                         uint32_t = 900
        maxImageArrayLayers:            uint32_t = 2048
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 31 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)

Thread 1, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    swapchain:                      VkSwapchainKHR = 0000018D6B185FE8
    timeout:                        uint64_t = 0
    semaphore:                      VkSemaphore = 0000000000000000
    fence:                          VkFence = 0000018D6B383088
    pImageIndex:                    uint32_t* = 2

Thread 1, Frame 5:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382A58
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 5:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB48
        pFences[0]:                     const VkFence = 0000018D6B382A58

Thread 1, Frame 5:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0000006FC3BFEC88:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 1, Frame 5:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0000006FC3BFECD0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0000018D6B2D51D8
        framebuffer:                    VkFramebuffer = 0000018D71630BD8
        renderArea:                     VkRect2D = 0000006FC3BFECF0:
            offset:                         VkOffset2D = 0000006FC3BFECF0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFECF8:
                width:                          uint32_t = 900
                height:                         uint32_t = 900
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0000006FC2F8CDAC
            pClearValues[0]:                const VkClearValue = 0000006FC2F8CDAC (Union):
                color:                          VkClearColorValue = 0000006FC2F8CDAC (Union):
                    float32:                        float[4] = 0000006FC2F8CDAC
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 0
                    int32:                          int32_t[4] = 0000006FC2F8CDAC
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 0
                    uint32:                         uint32_t[4] = 0000006FC2F8CDAC
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 0
                depthStencil:                   VkClearDepthStencilValue = 0000006FC2F8CDAC:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 1, Frame 5:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0000018D717ADD98

Thread 1, Frame 5:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0000006FC3BFEC28
        pViewports[0]:                  const VkViewport = 0000006FC3BFEC28:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 900
            height:                         float = 900
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 1, Frame 5:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0000006FC3BFEC58
        pScissors[0]:                   const VkRect2D = 0000006FC3BFEC58:
            offset:                         VkOffset2D = 0000006FC3BFEC58:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0000006FC3BFEC60:
                width:                          uint32_t = 900
                height:                         uint32_t = 900

Thread 1, Frame 5:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0000006FC3BFEB88
        pBuffers[0]:                    const VkBuffer = 0000018D71807E78
    pOffsets:                       const VkDeviceSize* = 0000006FC3BFED28
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 1, Frame 5:
vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    firstSet:                       uint32_t = 0
    descriptorSetCount:             uint32_t = 1
    pDescriptorSets:                const VkDescriptorSet* = 0000006FC2F8CD10
        pDescriptorSets[0]:             const VkDescriptorSet = 0000018D6B378A68
    dynamicOffsetCount:             uint32_t = 0
    pDynamicOffsets:                const uint32_t* = NULL

Thread 1, Frame 5:
vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    stageFlags:                     VkShaderStageFlags = 17 (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
    offset:                         uint32_t = 0
    size:                           uint32_t = 96
    pValues:                        const void* = 0000006FC3BFE560

Thread 1, Frame 5:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    vertexCount:                    uint32_t = 6
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 1, Frame 5:
vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    stageFlags:                     VkShaderStageFlags = 17 (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
    offset:                         uint32_t = 0
    size:                           uint32_t = 96
    pValues:                        const void* = 0000006FC3BFE560

Thread 1, Frame 5:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    vertexCount:                    uint32_t = 6
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 1, Frame 5:
vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    layout:                         VkPipelineLayout = 0000018D717AD8E8
    stageFlags:                     VkShaderStageFlags = 17 (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_ALL)
    offset:                         uint32_t = 0
    size:                           uint32_t = 96
    pValues:                        const void* = 0000006FC3BFE560

Thread 1, Frame 5:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8
    vertexCount:                    uint32_t = 6
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 1, Frame 5:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8

Thread 1, Frame 5:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0000018D718415D8

Thread 1, Frame 5:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 1, Frame 5:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0000018D6B18B040
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0000006FC3BFEB28
        pFences[0]:                     const VkFence = 0000018D6B383088

Thread 1, Frame 5:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0000006FC3BFED70
        pSubmits[0]:                    const VkSubmitInfo = 0000006FC3BFED70:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0000006FC3BFEB68
                pCommandBuffers[0]:             const VkCommandBuffer = 0000018D718415D8
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0000006FC3BFEBC8
                pSignalSemaphores[0]:           const VkSemaphore = 0000018D6B382278
    fence:                          VkFence = 0000018D6B382A58

Thread 1, Frame 5:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0000018D6B2D8A58
    pPresentInfo:                   const VkPresentInfoKHR* = 0000006FC3BFEE00:
        sType:                          VkStructureType = UNKNOWN (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0000006FC3BFEBC8
            pWaitSemaphores[0]:             const VkSemaphore = 0000018D6B382278
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0000006FC3BFEA88
            pSwapchains[0]:                 const VkSwapchainKHR = 0000018D6B185FE8
        pImageIndices:                  const uint32_t* = 0000006FC2F8CDA8
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

